
# GraphQL

## 目的
 - RESTのより深い理解
 - GatsbyにおけるGraphQLの理解
 - gRPCとの比較
 
## GraphQLとは
 - クエリ言語とスキーマ言語からなるWeb APIの規格
   - クエリ: リクエストのための言語。query, mutation, subscribeの3種類のクエリがある
   - スキーマ: APIの仕様を記述するための言語。
 - 特徴
   - レスポンスに含まれるデータの指定が必須であること
   - クエリとレスポンスの構造がよく似ていること

## GraphQL vs REST
 - GraphQLはレスポンスのフィールドを明示的に指定する
   - RESTの場合はクエリパラメータなどを使うしかない。
   - これによりRESTは設計がクライアントサイドの仕様に依存しやすかったが、GraphQLはその問題を解消している
 - GraphQLはキャッシュが最適化されている
   - RESTはパス単位でキャッシュする
   - GraphQLはオブジェクト単位でキャッシュする
 - GraphQLには型がある
 - GraphQLは開発者体験が改善されている
   - 補完・型チェック

### RESTの問題点
 - オブジェクトのグラフ構造とAPIレスポンス構造に乖離が生まれがち
   - GraphQLはクエリとレスポンス構造に対応関係があり、解消できる
 - クライアントの要求によって複数回のリクエストを組み合わせる必要がある(underfetch)
   - 逆に、使わない情報までレスポンスに返されることもある(overfetch)
   - GraphQLはこの問題を解消している
 - 設計が難しい
   - GraphQLではスキーマ言語に沿って設計すれば良い

## RESTの優位性
 - 処理系を実装するのが簡単
   - パス間の処理系が疎結合になるため
 - シンプル
   - 型、クエリ、リゾルバがGraphQLを複雑にしている
 - ライブラリが充実している

# gRPC
 - xmlrpc, json-rpc
 - protocol buffers
 - HTTP/2でRPCを実現するための規格
 - Pub/Sub, FireStore, QUIC
 - マイクロサービス向け

## メリット
 - インターフェース定義がprotoファイルを確認することで確実に把握できる
 - ルーティングの実装、enc/devとかが楽

## デメリット
 - ブラウザ(javascript)ではgrpc-gatewayを挟まないと使用できない
 - データがシリアライズされているので、通信内容の監視がしにくい

## gRPC vs  REST
 - レスポンスが独自プロトコル(Protocol Buffers)であり、シリアライザに対応する型に変換する必要がない
 - これにより送信データ量も少なくなり高速

### gRPC vs GraphQL
 - ただ、gRPCはGraphqlのように柔軟なクエリ（関数呼び出し）はない。
 - サービスという形でRPCの関数を呼び出し結果を得るが、その結果の形は固定。
 - また、Mediumの記事でも述べられている通り、gRPCは低レベル向き、GraphQLは高レベル向き。
